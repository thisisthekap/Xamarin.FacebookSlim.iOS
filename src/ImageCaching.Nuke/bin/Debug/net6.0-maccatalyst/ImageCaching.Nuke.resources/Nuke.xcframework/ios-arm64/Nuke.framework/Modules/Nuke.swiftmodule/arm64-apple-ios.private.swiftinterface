// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.7 (swiftlang-5.7.0.127.4 clang-1400.0.29.50)
// swift-module-flags: -target arm64-apple-ios11.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name Nuke
// swift-module-flags-ignorable: -enable-bare-slash-regex
import Combine
import CommonCrypto
import CoreImage
import Foundation
import ImageIO
import Swift
import SwiftUI
import UIKit.UIColor
import UIKit.UIImage
import UIKit
import _Concurrency
import _StringProcessing
import os
public protocol ImageProcessing {
  func process(_ image: Nuke.PlatformImage) -> Nuke.PlatformImage?
  func process(_ container: Nuke.ImageContainer, context: Nuke.ImageProcessingContext) -> Nuke.ImageContainer?
  var identifier: Swift.String { get }
  var hashableIdentifier: Swift.AnyHashable { get }
}
extension Nuke.ImageProcessing {
  public func process(_ container: Nuke.ImageContainer, context: Nuke.ImageProcessingContext) -> Nuke.ImageContainer?
  public var hashableIdentifier: Swift.AnyHashable {
    get
  }
}
public struct ImageProcessingContext {
  public let request: Nuke.ImageRequest
  public let response: Nuke.ImageResponse
  public let isFinal: Swift.Bool
  public init(request: Nuke.ImageRequest, response: Nuke.ImageResponse, isFinal: Swift.Bool)
}
public enum ImageProcessors {
}
extension Nuke.ImageProcessors {
  public struct Resize : Nuke.ImageProcessing, Swift.Hashable, Swift.CustomStringConvertible {
    public enum ContentMode : Swift.CustomStringConvertible {
      case aspectFill
      case aspectFit
      public var description: Swift.String {
        get
      }
      public static func == (a: Nuke.ImageProcessors.Resize.ContentMode, b: Nuke.ImageProcessors.Resize.ContentMode) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public init(size: CoreFoundation.CGSize, unit: Nuke.ImageProcessingOptions.Unit = .points, contentMode: Nuke.ImageProcessors.Resize.ContentMode = .aspectFill, crop: Swift.Bool = false, upscale: Swift.Bool = false)
    public init(width: CoreFoundation.CGFloat, unit: Nuke.ImageProcessingOptions.Unit = .points, upscale: Swift.Bool = false)
    public init(height: CoreFoundation.CGFloat, unit: Nuke.ImageProcessingOptions.Unit = .points, upscale: Swift.Bool = false)
    public func process(_ image: Nuke.PlatformImage) -> Nuke.PlatformImage?
    public var identifier: Swift.String {
      get
    }
    public var hashableIdentifier: Swift.AnyHashable {
      get
    }
    public var description: Swift.String {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Nuke.ImageProcessors.Resize, b: Nuke.ImageProcessors.Resize) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension Nuke.ImageProcessors {
  public struct Circle : Nuke.ImageProcessing, Swift.Hashable, Swift.CustomStringConvertible {
    public init(border: Nuke.ImageProcessingOptions.Border? = nil)
    public func process(_ image: Nuke.PlatformImage) -> Nuke.PlatformImage?
    public var identifier: Swift.String {
      get
    }
    public var hashableIdentifier: Swift.AnyHashable {
      get
    }
    public var description: Swift.String {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Nuke.ImageProcessors.Circle, b: Nuke.ImageProcessors.Circle) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension Nuke.ImageProcessors {
  public struct RoundedCorners : Nuke.ImageProcessing, Swift.Hashable, Swift.CustomStringConvertible {
    public init(radius: CoreFoundation.CGFloat, unit: Nuke.ImageProcessingOptions.Unit = .points, border: Nuke.ImageProcessingOptions.Border? = nil)
    public func process(_ image: Nuke.PlatformImage) -> Nuke.PlatformImage?
    public var identifier: Swift.String {
      get
    }
    public var hashableIdentifier: Swift.AnyHashable {
      get
    }
    public var description: Swift.String {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Nuke.ImageProcessors.RoundedCorners, b: Nuke.ImageProcessors.RoundedCorners) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension Nuke.ImageProcessors {
  public struct CoreImageFilter : Nuke.ImageProcessing, Swift.CustomStringConvertible {
    public let identifier: Swift.String
    public init(name: Swift.String, parameters: [Swift.String : Any], identifier: Swift.String)
    public init(name: Swift.String)
    public func process(_ image: Nuke.PlatformImage) -> Nuke.PlatformImage?
    public static var context: CoreImage.CIContext
    public static func apply(filter: CoreImage.CIFilter?, to image: Nuke.PlatformImage) -> Nuke.PlatformImage?
    public var description: Swift.String {
      get
    }
  }
}
extension Nuke.ImageProcessors {
  public struct GaussianBlur : Nuke.ImageProcessing, Swift.Hashable, Swift.CustomStringConvertible {
    public init(radius: Swift.Int = 8)
    public func process(_ image: Nuke.PlatformImage) -> Nuke.PlatformImage?
    public var identifier: Swift.String {
      get
    }
    public var hashableIdentifier: Swift.AnyHashable {
      get
    }
    public var description: Swift.String {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Nuke.ImageProcessors.GaussianBlur, b: Nuke.ImageProcessors.GaussianBlur) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension Nuke.ImageProcessors {
  public struct Composition : Nuke.ImageProcessing, Swift.Hashable, Swift.CustomStringConvertible {
    public init(_ processors: [Nuke.ImageProcessing])
    public func process(_ image: Nuke.PlatformImage) -> Nuke.PlatformImage?
    public func process(_ container: Nuke.ImageContainer, context: Nuke.ImageProcessingContext) -> Nuke.ImageContainer?
    public var identifier: Swift.String {
      get
    }
    public var hashableIdentifier: Swift.AnyHashable {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: Nuke.ImageProcessors.Composition, rhs: Nuke.ImageProcessors.Composition) -> Swift.Bool
    public var description: Swift.String {
      get
    }
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension Nuke.ImageProcessors {
  public struct Anonymous : Nuke.ImageProcessing, Swift.CustomStringConvertible {
    public let identifier: Swift.String
    public init(id: Swift.String, _ closure: @escaping (Nuke.PlatformImage) -> Nuke.PlatformImage?)
    public func process(_ image: Nuke.PlatformImage) -> Nuke.PlatformImage?
    public var description: Swift.String {
      get
    }
  }
}
public enum ImageProcessingOptions {
  public enum Unit : Swift.CustomStringConvertible {
    case points
    case pixels
    public var description: Swift.String {
      get
    }
    public static func == (a: Nuke.ImageProcessingOptions.Unit, b: Nuke.ImageProcessingOptions.Unit) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public struct Border : Swift.Hashable, Swift.CustomStringConvertible {
    public let width: CoreFoundation.CGFloat
    public let color: UIKit.UIColor
    public init(color: UIKit.UIColor, width: CoreFoundation.CGFloat = 1, unit: Nuke.ImageProcessingOptions.Unit = .points)
    public var description: Swift.String {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Nuke.ImageProcessingOptions.Border, b: Nuke.ImageProcessingOptions.Border) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public struct ImageResponse {
  public let container: Nuke.ImageContainer
  public var image: UIKit.UIImage {
    get
  }
  public let urlResponse: Foundation.URLResponse?
  public let cacheType: Nuke.ImageResponse.CacheType?
  public init(container: Nuke.ImageContainer, urlResponse: Foundation.URLResponse? = nil, cacheType: Nuke.ImageResponse.CacheType? = nil)
  public enum CacheType {
    case memory
    case disk
    public static func == (a: Nuke.ImageResponse.CacheType, b: Nuke.ImageResponse.CacheType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
public struct ImageContainer {
  public var image: UIKit.UIImage
  public var type: Nuke.ImageType?
  public var isPreview: Swift.Bool
  public var data: Foundation.Data?
  public var userInfo: [Nuke.ImageContainer.UserInfoKey : Any]
  public init(image: Nuke.PlatformImage, type: Nuke.ImageType? = nil, isPreview: Swift.Bool = false, data: Foundation.Data? = nil, userInfo: [Nuke.ImageContainer.UserInfoKey : Any] = [:])
  public func map(_ closure: (Nuke.PlatformImage) -> Nuke.PlatformImage?) -> Nuke.ImageContainer?
  public struct UserInfoKey : Swift.Hashable, Swift.ExpressibleByStringLiteral {
    public let rawValue: Swift.String
    public init(_ rawValue: Swift.String)
    public init(stringLiteral value: Swift.String)
    public static let scanNumberKey: Nuke.ImageContainer.UserInfoKey
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Nuke.ImageContainer.UserInfoKey, b: Nuke.ImageContainer.UserInfoKey) -> Swift.Bool
    public typealias ExtendedGraphemeClusterLiteralType = Swift.String
    public typealias StringLiteralType = Swift.String
    public typealias UnicodeScalarLiteralType = Swift.String
    public var hashValue: Swift.Int {
      get
    }
  }
}
public protocol ImageCaching : AnyObject {
  subscript(key: Nuke.ImageCacheKey) -> Nuke.ImageContainer? { get set }
  func removeAll()
}
public struct ImageCacheKey : Swift.Hashable {
  public init(key: Swift.String)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: Nuke.ImageCacheKey, b: Nuke.ImageCacheKey) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension Nuke.ImageCaching {
  public subscript(request: Nuke.ImageRequestConvertible) -> Nuke.ImageContainer? {
    get
    set
  }
}
final public class ImageCache : Nuke.ImageCaching {
  final public var costLimit: Swift.Int {
    get
    set
  }
  final public var countLimit: Swift.Int {
    get
    set
  }
  final public var ttl: Foundation.TimeInterval {
    get
    set
  }
  final public var totalCost: Swift.Int {
    get
  }
  final public var entryCostLimit: Swift.Double
  final public var totalCount: Swift.Int {
    get
  }
  public static let shared: Nuke.ImageCache
  @objc deinit
  public init(costLimit: Swift.Int = ImageCache.defaultCostLimit(), countLimit: Swift.Int = Int.max)
  public static func defaultCostLimit() -> Swift.Int
  final public subscript(key: Nuke.ImageCacheKey) -> Nuke.ImageContainer? {
    get
    set
  }
  final public func removeAll()
  final public func trim(toCost limit: Swift.Int)
  final public func trim(toCount limit: Swift.Int)
}
final public class ImagePipeline {
  public static var shared: Nuke.ImagePipeline
  final public let configuration: Nuke.ImagePipeline.Configuration
  final public var cache: Nuke.ImagePipeline.Cache {
    get
  }
  @available(*, deprecated, message: "Please use ImagePipelineDelegate")
  final public var observer: Nuke.ImagePipelineObserving?
  @objc deinit
  public init(configuration: Nuke.ImagePipeline.Configuration = Configuration(), delegate: Nuke.ImagePipelineDelegate? = nil)
  convenience public init(delegate: Nuke.ImagePipelineDelegate? = nil, _ configure: (inout Nuke.ImagePipeline.Configuration) -> Swift.Void)
  final public func invalidate()
  @discardableResult
  final public func loadImage(with request: Nuke.ImageRequestConvertible, completion: @escaping (_ result: Swift.Result<Nuke.ImageResponse, Nuke.ImagePipeline.Error>) -> Swift.Void) -> Nuke.ImageTask
  @discardableResult
  final public func loadImage(with request: Nuke.ImageRequestConvertible, queue: Dispatch.DispatchQueue? = nil, progress: ((_ response: Nuke.ImageResponse?, _ completed: Swift.Int64, _ total: Swift.Int64) -> Swift.Void)?, completion: @escaping ((_ result: Swift.Result<Nuke.ImageResponse, Nuke.ImagePipeline.Error>) -> Swift.Void)) -> Nuke.ImageTask
  @discardableResult
  final public func loadData(with request: Nuke.ImageRequestConvertible, completion: @escaping (Swift.Result<(data: Foundation.Data, response: Foundation.URLResponse?), Nuke.ImagePipeline.Error>) -> Swift.Void) -> Nuke.ImageTask
  @discardableResult
  final public func loadData(with request: Nuke.ImageRequestConvertible, queue: Dispatch.DispatchQueue? = nil, progress: ((_ completed: Swift.Int64, _ total: Swift.Int64) -> Swift.Void)?, completion: @escaping (Swift.Result<(data: Foundation.Data, response: Foundation.URLResponse?), Nuke.ImagePipeline.Error>) -> Swift.Void) -> Nuke.ImageTask
  public enum Error : Swift.Error, Swift.CustomStringConvertible {
    case dataLoadingFailed(Swift.Error)
    case decodingFailed
    case processingFailed(Nuke.ImageProcessing)
    public var description: Swift.String {
      get
    }
    public var dataLoadingError: Swift.Error? {
      get
    }
  }
}
public protocol Cancellable : AnyObject {
  func cancel()
}
public protocol DataLoading {
  func loadData(with request: Foundation.URLRequest, didReceiveData: @escaping (Foundation.Data, Foundation.URLResponse) -> Swift.Void, completion: @escaping (Swift.Error?) -> Swift.Void) -> Nuke.Cancellable
}
extension Foundation.URLSessionTask : Nuke.Cancellable {
}
final public class DataLoader : Nuke.DataLoading {
  final public let session: Foundation.URLSession
  final public var observer: Nuke.DataLoaderObserving?
  @objc deinit
  public init(configuration: Foundation.URLSessionConfiguration = DataLoader.defaultConfiguration, validate: @escaping (Foundation.URLResponse) -> Swift.Error? = DataLoader.validate)
  public static var defaultConfiguration: Foundation.URLSessionConfiguration {
    get
  }
  public static func validate(response: Foundation.URLResponse) -> Swift.Error?
  public static let sharedUrlCache: Foundation.URLCache
  final public func loadData(with request: Foundation.URLRequest, didReceiveData: @escaping (Foundation.Data, Foundation.URLResponse) -> Swift.Void, completion: @escaping (Swift.Error?) -> Swift.Void) -> Nuke.Cancellable
  public enum Error : Swift.Error, Swift.CustomStringConvertible {
    case statusCodeUnacceptable(Swift.Int)
    public var description: Swift.String {
      get
    }
  }
}
public enum DataTaskEvent {
  case resumed
  case receivedResponse(response: Foundation.URLResponse)
  case receivedData(data: Foundation.Data)
  case completed(error: Swift.Error?)
}
public protocol DataLoaderObserving {
  func dataLoader(_ loader: Nuke.DataLoader, urlSession: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceiveEvent event: Nuke.DataTaskEvent)
}
public protocol ImageEncoding {
  func encode(_ image: Nuke.PlatformImage) -> Foundation.Data?
  func encode(_ container: Nuke.ImageContainer, context: Nuke.ImageEncodingContext) -> Foundation.Data?
}
extension Nuke.ImageEncoding {
  public func encode(_ container: Nuke.ImageContainer, context: Nuke.ImageEncodingContext) -> Foundation.Data?
}
public struct ImageEncodingContext {
  public let request: Nuke.ImageRequest
  public let image: Nuke.PlatformImage
  public let urlResponse: Foundation.URLResponse?
}
public enum ImageEncoders {
}
extension Nuke.ImageEncoders {
  public struct Default : Nuke.ImageEncoding {
    public var compressionQuality: Swift.Float
    public var isHEIFPreferred: Swift.Bool
    public init(compressionQuality: Swift.Float = 0.8)
    public func encode(_ image: Nuke.PlatformImage) -> Foundation.Data?
  }
}
extension Nuke.ImageEncoders {
  public struct ImageIO : Nuke.ImageEncoding {
    public let type: Nuke.ImageType
    public let compressionRatio: Swift.Float
    public init(type: Nuke.ImageType, compressionRatio: Swift.Float = 0.8)
    public static func isSupported(type: Nuke.ImageType) -> Swift.Bool
    public func encode(_ image: Nuke.PlatformImage) -> Foundation.Data?
  }
}
@available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
extension Nuke.ImagePipeline {
  final public func imagePublisher(with request: Nuke.ImageRequestConvertible) -> Nuke.ImagePublisher
}
@available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
public struct ImagePublisher : Combine.Publisher {
  public typealias Output = Nuke.ImageResponse
  public typealias Failure = Nuke.ImagePipeline.Error
  public let request: Nuke.ImageRequest
  public let pipeline: Nuke.ImagePipeline
  public init(request: Nuke.ImageRequest, pipeline: Nuke.ImagePipeline)
  public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == Nuke.ImagePipeline.Error, S.Input == Nuke.ImageResponse
}
extension Nuke.ImagePipeline {
  public struct Cache {
    public subscript(request: Nuke.ImageRequestConvertible) -> Nuke.ImageContainer? {
      get
      nonmutating set
    }
    public func cachedImage(for request: Nuke.ImageRequestConvertible, caches: Nuke.ImagePipeline.Cache.Caches = [.all]) -> Nuke.ImageContainer?
    public func storeCachedImage(_ image: Nuke.ImageContainer, for request: Nuke.ImageRequestConvertible, caches: Nuke.ImagePipeline.Cache.Caches = [.all])
    public func removeCachedImage(for request: Nuke.ImageRequestConvertible, caches: Nuke.ImagePipeline.Cache.Caches = [.all])
    public func containsCachedImage(for request: Nuke.ImageRequestConvertible, caches: Nuke.ImagePipeline.Cache.Caches = [.all]) -> Swift.Bool
    public func cachedData(for request: Nuke.ImageRequestConvertible) -> Foundation.Data?
    public func storeCachedData(_ data: Foundation.Data, for request: Nuke.ImageRequestConvertible)
    public func containsData(for request: Nuke.ImageRequestConvertible) -> Swift.Bool
    public func removeCachedData(for request: Nuke.ImageRequestConvertible)
    public func makeImageCacheKey(for request: Nuke.ImageRequestConvertible) -> Nuke.ImageCacheKey
    public func makeDataCacheKey(for request: Nuke.ImageRequestConvertible) -> Swift.String
    public func removeAll(caches: Nuke.ImagePipeline.Cache.Caches = [.all])
    public struct Caches : Swift.OptionSet {
      public let rawValue: Swift.Int
      public init(rawValue: Swift.Int)
      public static let memory: Nuke.ImagePipeline.Cache.Caches
      public static let disk: Nuke.ImagePipeline.Cache.Caches
      public static let all: Nuke.ImagePipeline.Cache.Caches
      public typealias ArrayLiteralElement = Nuke.ImagePipeline.Cache.Caches
      public typealias Element = Nuke.ImagePipeline.Cache.Caches
      public typealias RawValue = Swift.Int
    }
  }
}
public protocol ImagePipelineDelegate : AnyObject {
  func dataLoader(for request: Nuke.ImageRequest, pipeline: Nuke.ImagePipeline) -> Nuke.DataLoading
  func dataCache(for request: Nuke.ImageRequest, pipeline: Nuke.ImagePipeline) -> Nuke.DataCaching?
  func imageDecoder(for context: Nuke.ImageDecodingContext, pipeline: Nuke.ImagePipeline) -> Nuke.ImageDecoding?
  func imageEncoder(for context: Nuke.ImageEncodingContext, pipeline: Nuke.ImagePipeline) -> Nuke.ImageEncoding
  func cacheKey(for request: Nuke.ImageRequest, pipeline: Nuke.ImagePipeline) -> Swift.String?
  func willCache(data: Foundation.Data, image: Nuke.ImageContainer?, for request: Nuke.ImageRequest, pipeline: Nuke.ImagePipeline, completion: @escaping (Foundation.Data?) -> Swift.Void)
  func pipeline(_ pipeline: Nuke.ImagePipeline, imageTask: Nuke.ImageTask, didReceiveEvent event: Nuke.ImageTaskEvent)
}
extension Nuke.ImagePipelineDelegate {
  public func dataLoader(for request: Nuke.ImageRequest, pipeline: Nuke.ImagePipeline) -> Nuke.DataLoading
  public func dataCache(for request: Nuke.ImageRequest, pipeline: Nuke.ImagePipeline) -> Nuke.DataCaching?
  public func imageDecoder(for context: Nuke.ImageDecodingContext, pipeline: Nuke.ImagePipeline) -> Nuke.ImageDecoding?
  public func imageEncoder(for context: Nuke.ImageEncodingContext, pipeline: Nuke.ImagePipeline) -> Nuke.ImageEncoding
  public func cacheKey(for request: Nuke.ImageRequest, pipeline: Nuke.ImagePipeline) -> Swift.String?
  public func willCache(data: Foundation.Data, image: Nuke.ImageContainer?, for request: Nuke.ImageRequest, pipeline: Nuke.ImagePipeline, completion: @escaping (Foundation.Data?) -> Swift.Void)
  public func pipeline(_ pipeline: Nuke.ImagePipeline, imageTask: Nuke.ImageTask, didReceiveEvent event: Nuke.ImageTaskEvent)
}
public enum ImageTaskEvent {
  case started
  case cancelled
  case priorityUpdated(priority: Nuke.ImageRequest.Priority)
  case intermediateResponseReceived(response: Nuke.ImageResponse)
  case progressUpdated(completedUnitCount: Swift.Int64, totalUnitCount: Swift.Int64)
  case completed(result: Swift.Result<Nuke.ImageResponse, Nuke.ImagePipeline.Error>)
}
public typealias PlatformImage = UIKit.UIImage
@objc public protocol Nuke_ImageDisplaying {
  @objc func nuke_display(image: Nuke.PlatformImage?, data: Foundation.Data?)
}
public typealias ImageDisplayingView = UIKit.UIView & Nuke.Nuke_ImageDisplaying
extension UIKit.UIImageView : Nuke.Nuke_ImageDisplaying {
  @_Concurrency.MainActor(unsafe) @objc dynamic open func nuke_display(image: UIKit.UIImage?, data: Foundation.Data? = nil)
}
@discardableResult
public func loadImage(with request: Nuke.ImageRequestConvertible?, options: Nuke.ImageLoadingOptions = ImageLoadingOptions.shared, into view: Nuke.ImageDisplayingView, completion: @escaping (_ result: Swift.Result<Nuke.ImageResponse, Nuke.ImagePipeline.Error>) -> Swift.Void) -> Nuke.ImageTask?
@discardableResult
public func loadImage(with request: Nuke.ImageRequestConvertible?, options: Nuke.ImageLoadingOptions = ImageLoadingOptions.shared, into view: Nuke.ImageDisplayingView, progress: ((_ response: Nuke.ImageResponse?, _ completed: Swift.Int64, _ total: Swift.Int64) -> Swift.Void)? = nil, completion: ((_ result: Swift.Result<Nuke.ImageResponse, Nuke.ImagePipeline.Error>) -> Swift.Void)? = nil) -> Nuke.ImageTask?
public func cancelRequest(for view: Nuke.ImageDisplayingView)
public struct ImageLoadingOptions {
  public static var shared: Nuke.ImageLoadingOptions
  public var placeholder: Nuke.PlatformImage?
  public var failureImage: Nuke.PlatformImage?
  public var transition: Nuke.ImageLoadingOptions.Transition?
  public var failureImageTransition: Nuke.ImageLoadingOptions.Transition?
  public var alwaysTransition: Swift.Bool
  public var isPrepareForReuseEnabled: Swift.Bool
  public var isProgressiveRenderingEnabled: Swift.Bool
  public var pipeline: Nuke.ImagePipeline?
  public var processors: [Nuke.ImageProcessing]?
  public var contentModes: Nuke.ImageLoadingOptions.ContentModes?
  public struct ContentModes {
    public var success: UIKit.UIView.ContentMode
    public var failure: UIKit.UIView.ContentMode
    public var placeholder: UIKit.UIView.ContentMode
    public init(success: UIKit.UIView.ContentMode, failure: UIKit.UIView.ContentMode, placeholder: UIKit.UIView.ContentMode)
  }
  public var tintColors: Nuke.ImageLoadingOptions.TintColors?
  public struct TintColors {
    public var success: UIKit.UIColor?
    public var failure: UIKit.UIColor?
    public var placeholder: UIKit.UIColor?
    public init(success: UIKit.UIColor?, failure: UIKit.UIColor?, placeholder: UIKit.UIColor?)
  }
  public init(placeholder: UIKit.UIImage? = nil, transition: Nuke.ImageLoadingOptions.Transition? = nil, failureImage: UIKit.UIImage? = nil, failureImageTransition: Nuke.ImageLoadingOptions.Transition? = nil, contentModes: Nuke.ImageLoadingOptions.ContentModes? = nil, tintColors: Nuke.ImageLoadingOptions.TintColors? = nil)
  public struct Transition {
    public static func fadeIn(duration: Foundation.TimeInterval, options: UIKit.UIView.AnimationOptions = .allowUserInteraction) -> Nuke.ImageLoadingOptions.Transition
    public static func custom(_ closure: @escaping (Nuke.ImageDisplayingView, UIKit.UIImage) -> Swift.Void) -> Nuke.ImageLoadingOptions.Transition
  }
  public init()
}
public protocol DataCaching {
  func cachedData(for key: Swift.String) -> Foundation.Data?
  func containsData(for key: Swift.String) -> Swift.Bool
  func storeData(_ data: Foundation.Data, for key: Swift.String)
  func removeData(for key: Swift.String)
  func removeAll()
}
final public class DataCache : Nuke.DataCaching {
  public typealias Key = Swift.String
  final public var sizeLimit: Swift.Int
  final public let path: Foundation.URL
  final public var sweepInterval: Swift.Double
  final public let queue: Dispatch.DispatchQueue
  public typealias FilenameGenerator = (_ key: Swift.String) -> Swift.String?
  convenience public init(name: Swift.String, filenameGenerator: @escaping (Swift.String) -> Swift.String? = DataCache.filename(for:)) throws
  public init(path: Foundation.URL, filenameGenerator: @escaping (Swift.String) -> Swift.String? = DataCache.filename(for:)) throws
  @objc deinit
  public static func filename(for key: Swift.String) -> Swift.String?
  final public func cachedData(for key: Nuke.DataCache.Key) -> Foundation.Data?
  final public func containsData(for key: Swift.String) -> Swift.Bool
  final public func storeData(_ data: Foundation.Data, for key: Nuke.DataCache.Key)
  final public func removeData(for key: Nuke.DataCache.Key)
  final public func removeAll()
  final public subscript(key: Nuke.DataCache.Key) -> Foundation.Data? {
    get
    set
  }
  final public func filename(for key: Nuke.DataCache.Key) -> Swift.String?
  final public func url(for key: Nuke.DataCache.Key) -> Foundation.URL?
  final public func flush()
  final public func flush(for key: Nuke.DataCache.Key)
  final public func sweep()
  final public var totalCount: Swift.Int {
    get
  }
  final public var totalSize: Swift.Int {
    get
  }
  final public var totalAllocatedSize: Swift.Int {
    get
  }
}
public struct ImageRequest : Swift.CustomStringConvertible {
  public var urlRequest: Foundation.URLRequest? {
    get
  }
  public var url: Foundation.URL? {
    get
  }
  public var imageId: Swift.String? {
    get
  }
  public var priority: Nuke.ImageRequest.Priority {
    get
    set
  }
  public var processors: [Nuke.ImageProcessing] {
    get
    set
  }
  public var options: Nuke.ImageRequest.Options {
    get
    set
  }
  public var userInfo: [Nuke.ImageRequest.UserInfoKey : Any] {
    get
    set
  }
  public enum Priority : Swift.Int, Swift.Comparable {
    case veryLow, low, normal, high, veryHigh
    public static func < (lhs: Nuke.ImageRequest.Priority, rhs: Nuke.ImageRequest.Priority) -> Swift.Bool
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public struct UserInfoKey : Swift.Hashable, Swift.ExpressibleByStringLiteral {
    public let rawValue: Swift.String
    public init(_ rawValue: Swift.String)
    public init(stringLiteral value: Swift.String)
    public static let imageIdKey: Nuke.ImageRequest.UserInfoKey
    public static let scaleKey: Nuke.ImageRequest.UserInfoKey
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Nuke.ImageRequest.UserInfoKey, b: Nuke.ImageRequest.UserInfoKey) -> Swift.Bool
    public typealias ExtendedGraphemeClusterLiteralType = Swift.String
    public typealias StringLiteralType = Swift.String
    public typealias UnicodeScalarLiteralType = Swift.String
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(url: Foundation.URL?, processors: [Nuke.ImageProcessing]? = nil, priority: Nuke.ImageRequest.Priority = .normal, options: Nuke.ImageRequest.Options = [], userInfo: [Nuke.ImageRequest.UserInfoKey : Any]? = nil)
  public init(urlRequest: Foundation.URLRequest, processors: [Nuke.ImageProcessing]? = nil, priority: Nuke.ImageRequest.Priority = .normal, options: Nuke.ImageRequest.Options = [], userInfo: [Nuke.ImageRequest.UserInfoKey : Any]? = nil)
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
  public init<P>(id: Swift.String, data: P, processors: [Nuke.ImageProcessing]? = nil, priority: Nuke.ImageRequest.Priority = .normal, options: Nuke.ImageRequest.Options = [], userInfo: [Nuke.ImageRequest.UserInfoKey : Any]? = nil) where P : Combine.Publisher, P.Output == Foundation.Data
  public struct Options : Swift.OptionSet, Swift.Hashable {
    public let rawValue: Swift.UInt16
    public init(rawValue: Swift.UInt16)
    public static let disableMemoryCacheReads: Nuke.ImageRequest.Options
    public static let disableMemoryCacheWrites: Nuke.ImageRequest.Options
    public static let disableMemoryCache: Nuke.ImageRequest.Options
    public static let disableDiskCacheReads: Nuke.ImageRequest.Options
    public static let disableDiskCacheWrites: Nuke.ImageRequest.Options
    public static let disableDiskCache: Nuke.ImageRequest.Options
    public static let reloadIgnoringCachedData: Nuke.ImageRequest.Options
    public static let returnCacheDataDontLoad: Nuke.ImageRequest.Options
    public typealias ArrayLiteralElement = Nuke.ImageRequest.Options
    public typealias Element = Nuke.ImageRequest.Options
    public typealias RawValue = Swift.UInt16
  }
  public var description: Swift.String {
    get
  }
}
public protocol ImageRequestConvertible {
  func asImageRequest() -> Nuke.ImageRequest
}
extension Nuke.ImageRequest : Nuke.ImageRequestConvertible {
  public func asImageRequest() -> Nuke.ImageRequest
}
extension Foundation.URL : Nuke.ImageRequestConvertible {
  public func asImageRequest() -> Nuke.ImageRequest
}
extension Swift.Optional : Nuke.ImageRequestConvertible where Wrapped == Foundation.URL {
  public func asImageRequest() -> Nuke.ImageRequest
}
extension Foundation.URLRequest : Nuke.ImageRequestConvertible {
  public func asImageRequest() -> Nuke.ImageRequest
}
extension Swift.String : Nuke.ImageRequestConvertible {
  public func asImageRequest() -> Nuke.ImageRequest
}
@available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
final public class FetchImage : Combine.ObservableObject, Swift.Identifiable {
  @Combine.Published @_projectedValueProperty($result) final public var result: Swift.Result<Nuke.ImageResponse, Swift.Error>? {
    get
  }
  final public var $result: Combine.Published<Swift.Result<Nuke.ImageResponse, Swift.Error>?>.Publisher {
    get
  }
  final public var image: Nuke.PlatformImage? {
    get
  }
  @Combine.Published @_projectedValueProperty($imageContainer) final public var imageContainer: Nuke.ImageContainer? {
    get
  }
  final public var $imageContainer: Combine.Published<Nuke.ImageContainer?>.Publisher {
    get
  }
  @Combine.Published @_projectedValueProperty($isLoading) final public var isLoading: Swift.Bool {
    get
  }
  final public var $isLoading: Combine.Published<Swift.Bool>.Publisher {
    get
  }
  final public var animation: SwiftUI.Animation?
  public struct Progress : Swift.Equatable {
    public let completed: Swift.Int64
    public let total: Swift.Int64
    public static func == (a: Nuke.FetchImage.Progress, b: Nuke.FetchImage.Progress) -> Swift.Bool
  }
  @Combine.Published @_projectedValueProperty($progress) final public var progress: Nuke.FetchImage.Progress {
    get
  }
  final public var $progress: Combine.Published<Nuke.FetchImage.Progress>.Publisher {
    get
  }
  final public var priority: Nuke.ImageRequest.Priority? {
    get
    set
  }
  final public var onStart: ((_ task: Nuke.ImageTask) -> Swift.Void)?
  final public var onProgress: ((_ response: Nuke.ImageResponse?, _ completed: Swift.Int64, _ total: Swift.Int64) -> Swift.Void)?
  final public var onSuccess: ((_ response: Nuke.ImageResponse) -> Swift.Void)?
  final public var onFailure: ((_ response: Swift.Error) -> Swift.Void)?
  final public var onCompletion: ((_ result: Swift.Result<Nuke.ImageResponse, Swift.Error>) -> Swift.Void)?
  final public var pipeline: Nuke.ImagePipeline
  final public var processors: [Nuke.ImageProcessing]?
  @objc deinit
  public init()
  final public func load(_ request: Nuke.ImageRequestConvertible?)
  final public func load<P>(_ publisher: P) where P : Combine.Publisher, P.Output == Nuke.ImageResponse
  final public func cancel()
  final public func reset()
  final public var view: SwiftUI.Image? {
    get
  }
  public typealias ID = Swift.ObjectIdentifier
  public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
}
public enum FetchImageError : Swift.Error {
  case sourceEmpty
  public static func == (a: Nuke.FetchImageError, b: Nuke.FetchImageError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Nuke.ImagePipeline {
  public struct Configuration {
    public var imageCache: Nuke.ImageCaching? {
      get
      set
    }
    public var dataLoader: Nuke.DataLoading
    public var dataCache: Nuke.DataCaching?
    public var makeImageDecoder: (Nuke.ImageDecodingContext) -> Nuke.ImageDecoding?
    public var makeImageEncoder: (Nuke.ImageEncodingContext) -> Nuke.ImageEncoding
    public var dataLoadingQueue: Foundation.OperationQueue
    public var dataCachingQueue: Foundation.OperationQueue
    public var imageDecodingQueue: Foundation.OperationQueue
    public var imageEncodingQueue: Foundation.OperationQueue
    public var imageProcessingQueue: Foundation.OperationQueue
    public var imageDecompressingQueue: Foundation.OperationQueue
    public var callbackQueue: Dispatch.DispatchQueue
    public var isDecompressionEnabled: Swift.Bool
    public var dataCachePolicy: Nuke.ImagePipeline.Configuration.DataCachePolicy
    public enum DataCachePolicy {
      case automatic
      case storeOriginalData
      case storeEncodedImages
      case storeAll
      public static func == (a: Nuke.ImagePipeline.Configuration.DataCachePolicy, b: Nuke.ImagePipeline.Configuration.DataCachePolicy) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    @available(*, deprecated, message: "Please use `dataCachePolicy` instead.")
    public var dataCacheOptions: Nuke.ImagePipeline.Configuration.DataCacheOptions {
      get
      set
    }
    @available(*, deprecated, message: "Please use `dataCachePolicy` instead. The recommended policy is the new `.automatic` policy.")
    public struct DataCacheOptions {
      public var storedItems: Swift.Set<Nuke.ImagePipeline.DataCacheItem>
    }
    public var isTaskCoalescingEnabled: Swift.Bool
    public var isRateLimiterEnabled: Swift.Bool
    public var isProgressiveDecodingEnabled: Swift.Bool
    public var isStoringPreviewsInMemoryCache: Swift.Bool
    public var isResumableDataEnabled: Swift.Bool
    public static var isSignpostLoggingEnabled: Swift.Bool {
      get
      set
    }
    public init(dataLoader: Nuke.DataLoading = DataLoader())
    public static var withURLCache: Nuke.ImagePipeline.Configuration {
      get
    }
    public static var withDataCache: Nuke.ImagePipeline.Configuration {
      get
    }
  }
}
@_hasMissingDesignatedInitializers final public class ImageTask : Swift.Hashable, Swift.CustomStringConvertible {
  final public let taskId: Swift.Int64
  final public let request: Nuke.ImageRequest
  final public var priority: Nuke.ImageRequest.Priority {
    get
    set
  }
  final public var completedUnitCount: Swift.Int64 {
    get
  }
  final public var totalUnitCount: Swift.Int64 {
    get
  }
  final public var progress: Foundation.Progress {
    get
  }
  @objc deinit
  final public func cancel()
  final public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: Nuke.ImageTask, rhs: Nuke.ImageTask) -> Swift.Bool
  final public var description: Swift.String {
    get
  }
  final public var hashValue: Swift.Int {
    get
  }
}
@available(*, deprecated, message: "Renamed to ImagePrefetcher")
public typealias ImagePreheater = Nuke.ImagePrefetcher
extension Nuke.ImagePrefetcher {
  @available(*, deprecated, message: "Renamed to startPrefetching")
  final public func startPreheating(with urls: [Foundation.URL])
  @available(*, deprecated, message: "Renamed to startPrefetching")
  final public func startPreheating(with requests: [Nuke.ImageRequest])
  @available(*, deprecated, message: "Renamed to stopPrefetching")
  final public func stopPreheating(with urls: [Foundation.URL])
  @available(*, deprecated, message: "Renamed to stopPrefetching")
  final public func stopPreheating(with requests: [Nuke.ImageRequest])
  @available(*, deprecated, message: "Renamed to stopPrefetching")
  final public func stopPreheating()
}
extension Nuke.ImagePipeline {
  @available(*, deprecated, message: "Use pipeline.cache[url] instead")
  final public func cachedImage(for url: Foundation.URL) -> Nuke.ImageContainer?
  @available(*, deprecated, message: "Use pipeline.cache[request] instead")
  final public func cachedImage(for request: Nuke.ImageRequest) -> Nuke.ImageContainer?
  @available(*, deprecated, message: "If needed, use pipeline.cache.makeDataCacheKey(for:) instead. For original image data, remove the processors from the request. In general, there should be no need to create the keys manually anymore.")
  final public func cacheKey(for request: Nuke.ImageRequest, item: Nuke.ImagePipeline.DataCacheItem) -> Swift.String
  @available(*, deprecated, message: "Please use `dataCachePolicy` instead. The recommended policy is the new `.automatic` policy.")
  public enum DataCacheItem {
    case originalImageData
    case finalImage
    public static func == (a: Nuke.ImagePipeline.DataCacheItem, b: Nuke.ImagePipeline.DataCacheItem) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(*, deprecated, message: "Please use ImagePipelineDelegate")
public protocol ImagePipelineObserving {
  func pipeline(_ pipeline: Nuke.ImagePipeline, imageTask: Nuke.ImageTask, didReceiveEvent event: Nuke.ImageTaskEvent)
}
@available(*, deprecated, message: "Please use the new initializer with `ImageRequest.Options`. It offers the same options and more. For more information see the migration guide at https://github.com/kean/Nuke/blob/master/Documentation/Migrations/Nuke%2010%20Migration%20Guide.md#imagerequestoptions.")
public struct ImageRequestOptions {
  @available(*, deprecated, message: "Please use `ImagePipeline.Options` instead: `disableMemoryCacheRead`, `disableMemoryCacheWrite`.")
  public struct MemoryCacheOptions {
    public var isReadAllowed: Swift.Bool
    public var isWriteAllowed: Swift.Bool
    public init(isReadAllowed: Swift.Bool = true, isWriteAllowed: Swift.Bool = true)
  }
  public var memoryCacheOptions: Nuke.ImageRequestOptions.MemoryCacheOptions
  public init(memoryCacheOptions: Nuke.ImageRequestOptions.MemoryCacheOptions = .init(), filteredURL: Swift.String? = nil, cacheKey: Swift.AnyHashable? = nil, loadKey: Swift.AnyHashable? = nil, userInfo: [Swift.AnyHashable : Any] = [:])
}
extension Nuke.ImageRequest {
  @available(*, deprecated, message: "Please use the new initializer with `ImageRequest.Options`. It offers the same options and more. For more information see the migration guide at https://github.com/kean/Nuke/blob/master/Documentation/Migrations/Nuke%2010%20Migration%20Guide.md#imagerequestoptions.")
  public init(url: Foundation.URL, processors: [Nuke.ImageProcessing] = [], cachePolicy: Nuke.ImageRequest.CachePolicy, priority: Nuke.ImageRequest.Priority = .normal, options: Nuke.ImageRequestOptions = .init())
  @available(*, deprecated, message: "Please use the new initializer with `ImageRequest.Options`. It offers the same options and more. For more information see the migration guide at https://github.com/kean/Nuke/blob/master/Documentation/Migrations/Nuke%2010%20Migration%20Guide.md#imagerequestoptions")
  public init(urlRequest: Foundation.URLRequest, processors: [Nuke.ImageProcessing] = [], cachePolicy: Nuke.ImageRequest.CachePolicy, priority: Nuke.ImageRequest.Priority = .normal, options: Nuke.ImageRequestOptions = .init())
  @available(*, deprecated, message: "Please use `ImageRequest.Options` instead, it offers the same options under the same names.")
  public var cachePolicy: Nuke.ImageRequest.CachePolicy {
    get
    set
  }
  @available(*, deprecated, message: "Please use `ImageRequest.Options` instead, it offers the same options under the same names. And .reloadIgnoringCachedData no longer affects URLCache!")
  public enum CachePolicy {
    case `default`
    @available(*, deprecated, message: "Please use `ImageRequest.Options` instead. This option is available under the same name: .reloadIgnoringCachedData. This option is also no longer affects URLCache!")
    case reloadIgnoringCachedData
    @available(*, deprecated, message: "Please use `ImageRequest.Options` instead. This option is available under the same name: .returnCacheDataDontLoad.")
    case returnCacheDataDontLoad
    public static func == (a: Nuke.ImageRequest.CachePolicy, b: Nuke.ImageRequest.CachePolicy) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension Nuke.ImageDecoders.Default {
  @available(*, deprecated, message: "Please use `ImageConatainer.UserInfoKey.scanNumber.")
  public static let scanNumberKey: Swift.String
}
extension Nuke.ImagePipeline.Configuration {
  @available(*, deprecated, message: "Please use `ImageConatainer` `data` instead. The default image decoder now automatically attaches image data to the ImageContainer type. To learn how to implement animated image support using this new type, see the new Image Formats guide https://github.com/kean/Nuke/blob/9.6.0/Documentation/Guides/image-formats.md. Also see Nuke 10 migration guide https://github.com/kean/Nuke/blob/master/Documentation/Migrations/Nuke%2010%20Migration%20Guide.md.")
  public static var isAnimatedImageDataEnabled: Swift.Bool {
    get
    set
  }
}
extension UIKit.UIImage {
  @available(*, deprecated, message: "Please use `ImageConatainer` `data` instead")
  public var animatedImageData: Foundation.Data? {
    get
    set
  }
}
extension Nuke.ImagePipeline.Configuration {
  @available(*, deprecated, message: "Please use `ImageConfiguration.default` and provide a `dataLoader` afterwards or use a closure-based ImagePipeline initializer.")
  public init(dataLoader: Nuke.DataLoading = DataLoader(), imageCache: Nuke.ImageCaching?)
  @available(*, deprecated, message: "Renamed to isTaskCoalescingEnabled")
  public var isDeduplicationEnabled: Swift.Bool {
    get
    set
  }
  @available(*, deprecated, message: "Deprecated and will be removed. Please use the new ImageLoadingOptions processors option, or create another way to apply processors by default.")
  public var processors: [Nuke.ImageProcessing] {
    get
    set
  }
}
@available(*, deprecated, message: "Please use ImageDecoders.Default directly")
public typealias ImageDecoder = Nuke.ImageDecoders.Default
@available(*, deprecated, message: "Please use ImageEncoders.Default directly")
public typealias ImageEncoder = Nuke.ImageEncoders.Default
public protocol ImageDecoding {
  var isAsynchronous: Swift.Bool { get }
  func decode(_ data: Foundation.Data) -> Nuke.ImageContainer?
  func decodePartiallyDownloadedData(_ data: Foundation.Data) -> Nuke.ImageContainer?
}
extension Nuke.ImageDecoding {
  public var isAsynchronous: Swift.Bool {
    get
  }
  public func decodePartiallyDownloadedData(_ data: Foundation.Data) -> Nuke.ImageContainer?
}
public enum ImageDecoders {
}
extension Nuke.ImageDecoders {
  final public class Default : Nuke.ImageDecoding, Nuke.ImageDecoderRegistering {
    public init()
    final public var isAsynchronous: Swift.Bool {
      get
    }
    public init?(data: Foundation.Data, context: Nuke.ImageDecodingContext)
    public init?(partiallyDownloadedData data: Foundation.Data, context: Nuke.ImageDecodingContext)
    final public func decode(_ data: Foundation.Data) -> Nuke.ImageContainer?
    final public func decodePartiallyDownloadedData(_ data: Foundation.Data) -> Nuke.ImageContainer?
    @objc deinit
  }
}
extension Nuke.ImageDecoders {
  public struct Empty : Nuke.ImageDecoding {
    public let isProgressive: Swift.Bool
    public var isAsynchronous: Swift.Bool {
      get
    }
    public init(imageType: Nuke.ImageType? = nil, isProgressive: Swift.Bool = false)
    public func decodePartiallyDownloadedData(_ data: Foundation.Data) -> Nuke.ImageContainer?
    public func decode(_ data: Foundation.Data) -> Nuke.ImageContainer?
  }
}
public protocol ImageDecoderRegistering : Nuke.ImageDecoding {
  init?(data: Foundation.Data, context: Nuke.ImageDecodingContext)
  init?(partiallyDownloadedData data: Foundation.Data, context: Nuke.ImageDecodingContext)
}
extension Nuke.ImageDecoderRegistering {
  public init?(partiallyDownloadedData data: Foundation.Data, context: Nuke.ImageDecodingContext)
}
final public class ImageDecoderRegistry {
  public static let shared: Nuke.ImageDecoderRegistry
  public init()
  final public func decoder(for context: Nuke.ImageDecodingContext) -> Nuke.ImageDecoding?
  final public func register<Decoder>(_ decoder: Decoder.Type) where Decoder : Nuke.ImageDecoderRegistering
  final public func register(_ match: @escaping (Nuke.ImageDecodingContext) -> Nuke.ImageDecoding?)
  final public func clear()
  @objc deinit
}
public struct ImageDecodingContext {
  public let request: Nuke.ImageRequest
  public let data: Foundation.Data
  public let isCompleted: Swift.Bool
  public let urlResponse: Foundation.URLResponse?
  public init(request: Nuke.ImageRequest, data: Foundation.Data, isCompleted: Swift.Bool, urlResponse: Foundation.URLResponse?)
}
public struct ImageType : Swift.ExpressibleByStringLiteral, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public init(stringLiteral value: Swift.String)
  public static let png: Nuke.ImageType
  public static let jpeg: Nuke.ImageType
  public static let gif: Nuke.ImageType
  public static let heic: Nuke.ImageType
  public static let webp: Nuke.ImageType
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: Nuke.ImageType, b: Nuke.ImageType) -> Swift.Bool
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
  public var hashValue: Swift.Int {
    get
  }
}
extension Nuke.ImageType {
  public init?(_ data: Foundation.Data)
}
final public class ImagePrefetcher {
  final public var isPaused: Swift.Bool {
    get
    set
  }
  final public var priority: Nuke.ImageRequest.Priority {
    get
    set
  }
  public enum Destination {
    case memoryCache
    case diskCache
    public static func == (a: Nuke.ImagePrefetcher.Destination, b: Nuke.ImagePrefetcher.Destination) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(pipeline: Nuke.ImagePipeline = ImagePipeline.shared, destination: Nuke.ImagePrefetcher.Destination = .memoryCache, maxConcurrentRequestCount: Swift.Int = 2)
  @objc deinit
  final public func startPrefetching(with requests: [Nuke.ImageRequestConvertible])
  final public func stopPrefetching(with requests: [Nuke.ImageRequestConvertible])
  final public func stopPrefetching()
}
extension Nuke.ImageProcessors.Resize.ContentMode : Swift.Equatable {}
extension Nuke.ImageProcessors.Resize.ContentMode : Swift.Hashable {}
extension Nuke.ImageProcessingOptions.Unit : Swift.Equatable {}
extension Nuke.ImageProcessingOptions.Unit : Swift.Hashable {}
extension Nuke.ImageResponse.CacheType : Swift.Equatable {}
extension Nuke.ImageResponse.CacheType : Swift.Hashable {}
extension Nuke.ImageRequest.Priority : Swift.Hashable {}
extension Nuke.ImageRequest.Priority : Swift.RawRepresentable {}
extension Nuke.FetchImageError : Swift.Equatable {}
extension Nuke.FetchImageError : Swift.Hashable {}
extension Nuke.ImagePipeline.Configuration.DataCachePolicy : Swift.Equatable {}
extension Nuke.ImagePipeline.Configuration.DataCachePolicy : Swift.Hashable {}
@available(*, deprecated, message: "Please use `dataCachePolicy` instead. The recommended policy is the new `.automatic` policy.")
extension Nuke.ImagePipeline.DataCacheItem : Swift.Equatable {}
@available(*, deprecated, message: "Please use `dataCachePolicy` instead. The recommended policy is the new `.automatic` policy.")
extension Nuke.ImagePipeline.DataCacheItem : Swift.Hashable {}
@available(*, deprecated, message: "Please use `ImageRequest.Options` instead, it offers the same options under the same names. And .reloadIgnoringCachedData no longer affects URLCache!")
extension Nuke.ImageRequest.CachePolicy : Swift.Equatable {}
@available(*, deprecated, message: "Please use `ImageRequest.Options` instead, it offers the same options under the same names. And .reloadIgnoringCachedData no longer affects URLCache!")
extension Nuke.ImageRequest.CachePolicy : Swift.Hashable {}
extension Nuke.ImagePrefetcher.Destination : Swift.Equatable {}
extension Nuke.ImagePrefetcher.Destination : Swift.Hashable {}
